/**

www.WrappedPlatform.com

⠀⠀⠀⣠⠖⠚⠉⠙⠲⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠾⠋⠉⠑⠢⣄⠀⠀⠀⠀⠀
⠀⢀⡞⠁⠀⠀⠀⠀⠀⠈⠓⠦⠤⠤⠴⠖⠒⠉⠉⠉⠉⠉⠉⠉⠒⠲⠦⠤⠤⠴⠟⠁⠀⠀⠀⠀⠀⠈⢷⡀⠀⠀⠀
⠀⣾⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣧⠀⠀⠀
⢸⡇⢀⡴⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢦⠀⢹⣆⠀⠀
⠈⢧⡞⣴⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣶⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠠⣤⢧⡾⠙⠀⠀
⠀⠈⢿⡇⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⣾⣣⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⠀⠀⠀⠀⢹⡾⠀⠀⠀⠀
⠀⠀⠘⣇⠀⠀⢀⡾⠀⠀⠀⠀⣾⣿⠀⠀⢸⣯⣿⣿⣿⣿⡇⠀⠀⣿⣷⠄⠀⠀⠀⠀⠈⣷⠀⠀⠀⣼⠁⠀⠀⠀⠀
⠀⠀⠀⠈⠳⠤⣼⠁⠀⠀⠀⠀⠈⠁⠀⠀⠸⣿⣿⣿⣿⣿⡇⠀⠀⠈⠉⠀⠀⠀⠀⠀⠀⠘⣧⠤⠞⠁⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠻⠿⠿⠿⠟⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣹⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠘⠲⠴⠟⠦⠴⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡟⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠹⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⢦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣶⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⠋⠁⠀⠀⠀⠀⠀⢀⡖⠚⣻⠀⠀⠀⠀⠀⠀⠀⠈⢻⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡏⠀⠀⠀⣾⠉⠙⢲⣼⡤⠞⠉⠀⠀⠀⢐⡆⠀⠀⠀⠈⣯⢧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠇⠀⠀⠀⠈⣩⠉⠉⠙⣆⠀⠀⠀⠀⠀⣸⠇⠀⠀⠀⠀⢹⡈⢷⡄⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⠀⠀⠀⠀⢰⡏⠀⠀⠀⠸⡆⠀⠀⣠⡶⠋⠀⠀⠀⠀⠀⢸⡇⠀⢿⡀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⡏⠀⠀⠀⠀⢸⡇⠀⠀⠀⢀⡿⠶⠋⠉⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⠘⣗⠲⣆⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢠⡖⠋⠙⠲⡇⠀⠀⠀⠀⢸⠀⣰⠤⢥⣿⠤⠤⠄⠀⠀⠀⠀⠀⣀⣤⠞⠁⠀⠀⠀⢹⡆⠛⢶⡄⠀⠀⠀
⠀⠀⠀⠀⡟⠀⠀⠀⠀⡇⠀⠀⠀⠀⢸⣸⠃⠀⠀⠙⢷⣖⣃⣠⡤⠴⠖⠋⠉⠀⠀⠀⠀⠀⠀⠈⣷⠀⡼⠃⠀⠀⠀
⠀⠀⠀⢸⡇⠀⠀⠀⠀⡇⠀⠀⠀⠀⢸⡟⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣠⠏⠀⠀⠀⠀
⠀⠀⠀⠈⣧⠀⠀⠀⠀⣷⠀⠀⠀⠀⣼⣇⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡿⠋⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠘⣧⠀⠀⠀⢿⣀⡀⠀⠀⡿⢻⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡴⠟⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠈⠳⠤⠤⠼⢷⣇⣸⡾⠓⠚⠳⣄⣀⠀⠀⠀⠀⣀⣀⣀⣠⡤⠤⠴⠖⠛⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 _  _  _                                 _    ______  _             ___                  
| || || |                               | |  (_____ \| |      _    / __)                 
| || || | ____ ____ ____  ____   ____ _ | |   _____) ) | ____| |_ | |__ ___   ____ ____  
| ||_|| |/ ___) _  |  _ \|  _ \ / _  ) || |  |  ____/| |/ _  |  _)|  __) _ \ / ___)    \ 
| |___| | |  ( ( | | | | | | | ( (/ ( (_| |  | |     | ( ( | | |__| | | |_| | |   | | | |
 \______|_|   \_||_| ||_/| ||_/ \____)____|  |_|     |_|\_||_|\___)_|  \___/|_|   |_|_|_|
                   |_|   |_|                                                             ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 */
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;


import "./MyDN404.sol";
import "./IMyDN404.sol";
import "hardhat/console.sol";
import "@openzeppelin/contracts/proxy/Clones.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

contract LaunchpadFactory {
    
    /// The information of the Launchpad Factory Management
    // DN404 initial contract address for clone
    address internal implementation ;
    struct launchpadFactoryStorage {
        address  ownerAddress ;
        address  marketingAddress ;
        address  developerAddress ;
        uint256  amountForMarketing ;
        uint256  amountForDeveloper ;
        uint256  earningsForMarketing ;
        uint256  earningsForDeveloper ;
        uint256  taxForDeveloper ;
        uint256  taxForMarketing ;
        uint256  creatingFee ;
        uint256  burnFee ;
        uint256  taxForSell ;
        uint256  taxForBuy ;
        uint256  swapFee ;
    }
    launchpadFactoryStorage public LaunchpadFactoryStorage;
    
    // deployed DN404 tokens information
    mapping(uint256 => address) public tokenAddress ;
    mapping(address => uint256) public idForToken ;
    uint256 currentTokenNumber ;
    event setWalletsEvent(address _marketingAddress, address _developerAddress);
    event setFeesEvent(uint256 _creatingFee, uint256 _burnFee, uint256 _taxForDeveloper, 
        uint256 _taxForMarketing, uint256 _taxForSell, uint256 _taxForBuy, uint _swapFee) ;
    event createTokenEvent(string _name, string _symbol, uint256 _totalSupply);
    event withdrawEvent(address from, uint256 amount) ;
    // Modifier
    modifier onlyOwner(){
        require(LaunchpadFactoryStorage.ownerAddress == msg.sender, "Only owner can set wallet addresses for Launchpad Factory") ;
        _;
    }

    // Constrcutor
    constructor(address _implementation){
        implementation = _implementation;
        LaunchpadFactoryStorage.ownerAddress = msg.sender ;
        LaunchpadFactoryStorage.marketingAddress = 0x87d9B8C3B43E0D95c169B9157662Dd89761ABa97 ;
        LaunchpadFactoryStorage.developerAddress = 0x9319Ec01DcB2086dc828C9A23Fa32DFb2FE10143 ;
        LaunchpadFactoryStorage.creatingFee = 1 * 10 ** 16 ;
        LaunchpadFactoryStorage.burnFee = 1 * 10 ** 16 ;
        LaunchpadFactoryStorage.taxForDeveloper = 15 ;
        LaunchpadFactoryStorage.taxForMarketing = 85 ;
        LaunchpadFactoryStorage.taxForSell = 10 ;
        LaunchpadFactoryStorage.taxForBuy = 10 ;
        LaunchpadFactoryStorage.swapFee = 10 ; 
    }

    // Set Marketing and Developer wallet, earnigs and amount for withdraw
    function setWalletsForLaunchpadFactory(address _marketingAddress, address _developerAddress) public onlyOwner{
        LaunchpadFactoryStorage.marketingAddress = _marketingAddress ;
        LaunchpadFactoryStorage.developerAddress = _developerAddress ;
        LaunchpadFactoryStorage.amountForMarketing = 0 ;
        LaunchpadFactoryStorage.amountForDeveloper = 0 ;
        currentTokenNumber = 0 ;
        LaunchpadFactoryStorage.earningsForMarketing = 0 ;
        LaunchpadFactoryStorage.earningsForDeveloper = 0 ;
        emit setWalletsEvent(_marketingAddress, _developerAddress) ;
    }

    // Set the fees 
    function setFeesForLaunchpadFactory(uint256 _creatingFee, uint256 _burnFee, uint256 _taxForDeveloper, 
        uint256 _taxForMarketing, uint256 _taxForSell, uint256 _taxForBuy, uint _swapFee) public onlyOwner returns(bool){
        LaunchpadFactoryStorage.creatingFee = _creatingFee ;
        LaunchpadFactoryStorage.burnFee = _burnFee ;
        LaunchpadFactoryStorage.taxForDeveloper = _taxForDeveloper ;
        LaunchpadFactoryStorage.taxForMarketing = _taxForMarketing ;
        LaunchpadFactoryStorage.taxForSell = _taxForSell ;
        LaunchpadFactoryStorage.taxForBuy = _taxForBuy ;
        LaunchpadFactoryStorage.swapFee = _swapFee ; 
        emit setFeesEvent(_creatingFee, _burnFee, _taxForDeveloper, _taxForMarketing, _taxForSell, _taxForBuy, _swapFee);
        return true ;
    }
    
    // Create new DN404 token using proxy clone and set the initial values of token
    function createToken(string calldata _name, string calldata _symbol, uint256 _totalSupply) external payable {
        // Checking if the amount sent is enough
        uint256 amount = msg.value ;
        require(amount >= LaunchpadFactoryStorage.creatingFee, "The amount sent is not enough to create a Launchpad") ;
        address newDeployedAddress = Clones.clone(implementation) ;
        console.log("newDeployedAddress: %s", newDeployedAddress) ;
        console.log("msg.sender: %s", msg.sender) ;
        bytes memory ownerAddressData = abi.encode(msg.sender) ;
        
        IMyDN404(newDeployedAddress).initialize(_name, _symbol, _totalSupply, ownerAddressData);        
        IMyDN404(newDeployedAddress).setBuyAndSellFee(LaunchpadFactoryStorage.taxForBuy, LaunchpadFactoryStorage.taxForSell);
        
        unchecked {
            ++ currentTokenNumber;
        }
        tokenAddress[currentTokenNumber] = newDeployedAddress ;
        idForToken[newDeployedAddress] = currentTokenNumber ;
        emit createTokenEvent(_name, _symbol, _totalSupply);
    }
    

    
    // Calc the marketing and developer amount for withdraw
    function calculateProfitShare(uint256 _totalBalance) internal {
        uint256 devShare = _totalBalance - (LaunchpadFactoryStorage.amountForDeveloper + LaunchpadFactoryStorage.amountForMarketing);
        LaunchpadFactoryStorage.amountForDeveloper += devShare * LaunchpadFactoryStorage.taxForDeveloper / 100;
        LaunchpadFactoryStorage.amountForMarketing += devShare * LaunchpadFactoryStorage.taxForMarketing / 100;
    }

    // Withdraw for Developer
    function withdrawForDeveloper() public {
        require(msg.sender == LaunchpadFactoryStorage.developerAddress, "Only developer can withdraw");
        uint256 totalBalance = address(this).balance ;
        require(totalBalance > 0, "No balance to withdraw");
        calculateProfitShare(totalBalance);
        uint256 amount = LaunchpadFactoryStorage.amountForDeveloper ;
        LaunchpadFactoryStorage.amountForDeveloper = 0;
        if(amount > 0)payable (LaunchpadFactoryStorage.developerAddress).transfer(amount);
        emit withdrawEvent(msg.sender, amount);
    }

    // Withdraw for Marketing
    function withdrawForMarketing() public{
        require(msg.sender == LaunchpadFactoryStorage.marketingAddress, "Only marketing can withdraw");
        uint256 totalBalance = address(this).balance ;
        require(totalBalance > 0, "No balance to withdraw");
        calculateProfitShare(totalBalance);
        uint256 amount = LaunchpadFactoryStorage.amountForMarketing;  
        LaunchpadFactoryStorage.amountForMarketing = 0;
        if(amount > 0) payable (LaunchpadFactoryStorage.marketingAddress).transfer(amount);
        emit withdrawEvent(msg.sender, amount);
    }
    
    // Returns total number of tokens
    function getCurrentTokenNumber() public view returns(uint256){
        return currentTokenNumber ;
    }
    
    // Returns id => address of token
    function getTokenAddress(uint256 id) public view returns(address){
        return tokenAddress[id] ;
    }

    receive() external payable{}
    fallback() external payable{}

}