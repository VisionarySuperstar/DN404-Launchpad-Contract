/**

www.WrappedPlatform.com

⠀⠀⠀⣠⠖⠚⠉⠙⠲⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠾⠋⠉⠑⠢⣄⠀⠀⠀⠀⠀
⠀⢀⡞⠁⠀⠀⠀⠀⠀⠈⠓⠦⠤⠤⠴⠖⠒⠉⠉⠉⠉⠉⠉⠉⠒⠲⠦⠤⠤⠴⠟⠁⠀⠀⠀⠀⠀⠈⢷⡀⠀⠀⠀
⠀⣾⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣧⠀⠀⠀
⢸⡇⢀⡴⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢦⠀⢹⣆⠀⠀
⠈⢧⡞⣴⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣶⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠠⣤⢧⡾⠙⠀⠀
⠀⠈⢿⡇⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⣾⣣⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⠀⠀⠀⠀⢹⡾⠀⠀⠀⠀
⠀⠀⠘⣇⠀⠀⢀⡾⠀⠀⠀⠀⣾⣿⠀⠀⢸⣯⣿⣿⣿⣿⡇⠀⠀⣿⣷⠄⠀⠀⠀⠀⠈⣷⠀⠀⠀⣼⠁⠀⠀⠀⠀
⠀⠀⠀⠈⠳⠤⣼⠁⠀⠀⠀⠀⠈⠁⠀⠀⠸⣿⣿⣿⣿⣿⡇⠀⠀⠈⠉⠀⠀⠀⠀⠀⠀⠘⣧⠤⠞⠁⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠻⠿⠿⠿⠟⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣹⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠘⠲⠴⠟⠦⠴⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡟⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠹⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⢦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣶⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⠋⠁⠀⠀⠀⠀⠀⢀⡖⠚⣻⠀⠀⠀⠀⠀⠀⠀⠈⢻⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡏⠀⠀⠀⣾⠉⠙⢲⣼⡤⠞⠉⠀⠀⠀⢐⡆⠀⠀⠀⠈⣯⢧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠇⠀⠀⠀⠈⣩⠉⠉⠙⣆⠀⠀⠀⠀⠀⣸⠇⠀⠀⠀⠀⢹⡈⢷⡄⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⠀⠀⠀⠀⢰⡏⠀⠀⠀⠸⡆⠀⠀⣠⡶⠋⠀⠀⠀⠀⠀⢸⡇⠀⢿⡀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⡏⠀⠀⠀⠀⢸⡇⠀⠀⠀⢀⡿⠶⠋⠉⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⠘⣗⠲⣆⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢠⡖⠋⠙⠲⡇⠀⠀⠀⠀⢸⠀⣰⠤⢥⣿⠤⠤⠄⠀⠀⠀⠀⠀⣀⣤⠞⠁⠀⠀⠀⢹⡆⠛⢶⡄⠀⠀⠀
⠀⠀⠀⠀⡟⠀⠀⠀⠀⡇⠀⠀⠀⠀⢸⣸⠃⠀⠀⠙⢷⣖⣃⣠⡤⠴⠖⠋⠉⠀⠀⠀⠀⠀⠀⠈⣷⠀⡼⠃⠀⠀⠀
⠀⠀⠀⢸⡇⠀⠀⠀⠀⡇⠀⠀⠀⠀⢸⡟⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣠⠏⠀⠀⠀⠀
⠀⠀⠀⠈⣧⠀⠀⠀⠀⣷⠀⠀⠀⠀⣼⣇⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡿⠋⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠘⣧⠀⠀⠀⢿⣀⡀⠀⠀⡿⢻⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡴⠟⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠈⠳⠤⠤⠼⢷⣇⣸⡾⠓⠚⠳⣄⣀⠀⠀⠀⠀⣀⣀⣀⣠⡤⠤⠴⠖⠛⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 _  _  _                                 _    ______  _             ___                  
| || || |                               | |  (_____ \| |      _    / __)                 
| || || | ____ ____ ____  ____   ____ _ | |   _____) ) | ____| |_ | |__ ___   ____ ____  
| ||_|| |/ ___) _  |  _ \|  _ \ / _  ) || |  |  ____/| |/ _  |  _)|  __) _ \ / ___)    \ 
| |___| | |  ( ( | | | | | | | ( (/ ( (_| |  | |     | ( ( | | |__| | | |_| | |   | | | |
 \______|_|   \_||_| ||_/| ||_/ \____)____|  |_|     |_|\_||_|\___)_|  \___/|_|   |_|_|_|
                   |_|   |_|                                                             ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 */
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./DN404.sol";
import "./DN404Mirror.sol";
import "hardhat/console.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

/**
 * @title MyDN404
 * @notice Sample DN404 contract that demonstrates the owner selling NFTs rather than the fungible token.
 * The underlying call still mints ERC20 tokens, but to the end user it'll appear as a standard NFT mint.
 * Each address is limited to MAX_PER_WALLET total mints.
 */
contract MyDN404 is DN404{
    using Strings for uint256;
    
    string public _name;
    string public _symbol;
    string public _baseURI;
    
    address public ownerAddress ;
    
    // proxy contract address
    address private proxy ;
    
    // tax for users during buy and sell
    uint256 taxForBuy ;
    uint256 taxForSell ;

    mapping(address => uint256) buyAmountUser ;
    mapping(address => uint256) soldAmountUser ;
    mapping(address => uint256) buyTimeUser ;

    // enum SaleOption {PRESALE, STEALTH, FAIR_LAUNCH}
    struct Customer404Storage {
        SaleOption saleOption; 
        uint256 preSalePrice ; 
        uint256 preSalePercent ;
        bool whiteListState; 
        uint256 vestingPeriod;
        uint256 vestingPercent;
        uint256 softCap; 
        uint256 hardCap; 
        uint256 minBuy; 
        uint256 maxBuy; 
        bool refundType;
        uint256 liquidityPercent; 
        uint256 listingPrice; 
        uint256 startTime; 
        uint256 endTime; 
        uint256 lockupTime;
        uint256 amountSold ; 
        uint256 earnings ;
        uint256 leftAmount ;
    }
    
    Customer404Storage public tokenStorage;

    // Modifiers

    modifier onlyOwner{
        require(msg.sender == ownerAddress, "Owner address is only allowed") ;
        _;
    }
    modifier beforeStartTime(){
        require(block.timestamp <= tokenStorage.startTime, "Should be less than start time") ;
        _;
    }

    modifier afterEndTime(){
        require(block.timestamp >= tokenStorage.endTime, "Should be after the end time") ;
        _;
    }

    // This function is called when token created
    function initialize(
        string memory name_,
        string memory symbol_,
        uint256 initialTokenSupply,
        bytes memory _ownerData
        
    ) initializer external
    {
        address _owner = abi.decode(_ownerData, (address)) ;
        ownerAddress = _owner ;
        _name = name_;
        _symbol = symbol_;
        initialTokenSupply *= _unit() ;
        address mirror = address(new DN404Mirror(msg.sender));
        _initializeDN404(initialTokenSupply, _owner, mirror);
        proxy = msg.sender ;
        
    }

    // get buyFee and sellFee from proxy contract
    function setBuyAndSellFee(uint256 _taxForBuy, uint256 _taxForSell) public {
        require(msg.sender == proxy, "Only proxy can set fees");
        taxForBuy = _taxForBuy;
        taxForSell = _taxForSell;
    }
    // set all of token informations from owner
    function setAllOfSettings(
        SaleOption _saleOption, 
        uint256 _preSalePrice, 
        uint256 _preSalePercent, 
        bool _whiteListState, 
        uint256 _vestingPeriod,
        uint256 _vestingPercent,
        uint256 _softCap, 
        uint256 _hardCap, 
        uint256 _minBuy, 
        uint256 _maxBuy, 
        bool _refundType, 
        uint256 _liquidityPercent, 
        uint256 _listingPrice, 
        uint256 _startTime, 
        uint256 _endTime, 
        uint256 _lockupTime,
        string memory baseURI) public onlyOwner{
        
        // Setting the initialization parameters
        tokenStorage.saleOption = _saleOption;
        tokenStorage.preSalePrice = _preSalePrice;
        tokenStorage.preSalePercent = _preSalePercent;
        tokenStorage.whiteListState = _whiteListState;
        tokenStorage.vestingPeriod = _vestingPeriod;
        tokenStorage.vestingPercent = _vestingPercent;
        tokenStorage.softCap = _softCap;
        tokenStorage.hardCap = _hardCap;
        tokenStorage.minBuy = _minBuy;
        tokenStorage.maxBuy = _maxBuy;
        tokenStorage.refundType = _refundType;
        tokenStorage.liquidityPercent = _liquidityPercent;
        tokenStorage.listingPrice = _listingPrice;
        tokenStorage.startTime = _startTime;
        tokenStorage.endTime = _endTime;
        tokenStorage.lockupTime = _lockupTime;
        tokenStorage.amountSold = 0 ;
        tokenStorage.leftAmount = totalSupply() * _preSalePercent ;
        _baseURI = baseURI;

        // put this contract as whitelisted so that NFT mint does not happen
        _setSkipNFT(address(this), true) ;

    }

    function _transfer(address from, address to, uint256 amount) internal override {
        if(tokenStorage.saleOption == SaleOption.PRESALE && buyAmountUser[from] > 0){
            uint256 _amount = buyAmountUser[from] ;
            uint256 currentTime = block.timestamp ;
            uint256 amountAvailableForSell = ((currentTime - buyTimeUser[from]) / (tokenStorage.vestingPeriod * 3600 * 24) * tokenStorage.vestingPercent) * _amount / 100 ;
            require(amountAvailableForSell <= soldAmountUser[from] + amount, "You could sell this amount.") ;
            soldAmountUser[from] += amount ; 
        }
        super._transfer(from, to, amount);
    }

    // Get the price for buying tokens including fee during PreSell 
    function getPriceForBuyingTokenDuringPreSell(
        uint256 amount) external view returns (uint256){
        
        uint256 initialPayAmount = amount * tokenStorage.preSalePrice;
        uint256 feeAdded = initialPayAmount * taxForBuy / 100;
        uint256 totalPay = initialPayAmount + feeAdded;
        return totalPay ;

    }

    // Main process for buying tokens during PreSell
    function buyTokenDuringPreSell(uint256 amount) external payable {
        
         if(tokenStorage.saleOption == SaleOption.STEALTH){
            return ;
        }
        if(tokenStorage.whiteListState){
            // Check if msg.sender is valid for buying because owner selected as whitelist members can buy tokens during PreSell
            bool isWhiteListedAddress = _getSkipNFT(msg.sender) ;
            require(isWhiteListedAddress, "Address not in whitelist") ;
        }
        else{
            // Set msg.sender as a whitelist member to prevent NFT mint during PreSell
            _setSkipNFT(msg.sender, true) ;
        }
        // Check if PreSell is active
        require(block.timestamp >= tokenStorage.startTime && block.timestamp <= tokenStorage.endTime, "Sale is not active");
    
        // Check minimum and maximum amount
        require(amount >= tokenStorage.minBuy && amount + buyAmountUser[msg.sender] <= tokenStorage.maxBuy, "Amount is not within limits");
  
        // Check if all amounts exceeds the presale amount
        uint256 currentvalue = totalSupply() / _unit() * tokenStorage.preSalePercent / 100 ;
        require(amount + tokenStorage.amountSold <= currentvalue, "Presale limit exceeded");
        
        // Check if enough eth sent
        uint256 initialPayAmount = amount * tokenStorage.preSalePrice;
        uint256 feeAdded = initialPayAmount * taxForBuy / 100;
        uint256 totalPay = initialPayAmount + feeAdded;
        require(msg.value >= totalPay, "Not enough ETH sent");

        // Transfer tokens
        _transfer(address(this), msg.sender, amount * _unit()) ;
        
        if(tokenStorage.saleOption == SaleOption.PRESALE){
            buyAmountUser[msg.sender] += amount ;
            buyTimeUser[msg.sender] = block.timestamp ;
        }

        // token left amount
        tokenStorage.leftAmount -= amount ;

        // add sold amount
        unchecked {
            tokenStorage.amountSold += amount;
        }

        // Refund extra amount if any
        uint256 amountToRefund = msg.value - totalPay;
        if(amountToRefund > 0){
            payable (msg.sender).transfer(amountToRefund);
        }
       
        // save fees for owner
        uint256 earnedOfOwner = initialPayAmount - initialPayAmount * (taxForSell / 100);
        tokenStorage.earnings += earnedOfOwner ;
        
        // save fees for marketing and developer
        uint256 leftAmount = totalPay - earnedOfOwner;
        payable (proxy).transfer(leftAmount) ;

    }

    // Owner withdraw all of his earning
    function withdraw() external onlyOwner{
        
        // Transfer tokens to owner
        payable(ownerAddress).transfer(address(this).balance);
    
    }

    // Function to set the data URI, which can be used for additional metadata (change as needed)
    function setBaseURI(string calldata baseURI) public onlyOwner {
        _baseURI = baseURI;
    }
    
    // tokenURI function to return the base URI for token metadata; users can implement logic to return unique URIs per token ID
    function tokenURI(uint256 tokenId) external view  returns (string memory){
        return _tokenURI(tokenId) ;
    }

    function _tokenURI(uint256 tokenId) internal view virtual override returns (string memory) {
        require(!_exists(tokenId), "Invalid token") ;

        string memory baseURI = baseURI_();
        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : '';
    }
    function baseURI_() internal view returns (string memory) {
        return _baseURI;
    }

    // Returns token name
    function name() public view override returns (string memory) {
        return _name;
    }

    // Returns token symbol
    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    // Allows the owner to update the token's name and symbol post-deployment (optional flexibility)
    function setNameSymbol(string calldata name__, string memory symbol__) public onlyOwner {
        _name = name__ ;
        _symbol = symbol__ ;
    }


    // Allows owner to upload address to whitelist
    function setWhitelist(address to, bool state) public onlyOwner{
        _setSkipNFT(to, state) ;
    }

    // Allows owner to upload addresses to white list
    function setWhitelistBatch(address[] calldata targets, bool[] calldata state) public onlyOwner {
        for(uint256 i = 0 ; i < targets.length ; i++){
            _setSkipNFT(targets[i], state[i]) ;
        }
    }

    /// Reset the token information in tokenStorage

    function setSaleOption(SaleOption option) public beforeStartTime onlyOwner{
        tokenStorage.saleOption = option ;
    }

    

    function setPreSalePrice(uint256 price) public beforeStartTime onlyOwner{
        tokenStorage.preSalePrice = price ;
    }

    function setPreSalePercent(uint256 percent) public beforeStartTime onlyOwner{
        tokenStorage.preSalePercent = percent ;
    }

    function setWhitelistState(bool state) public beforeStartTime onlyOwner{
        tokenStorage.whiteListState = state ;
    }

     function setVestingPeriod(uint256 period) public beforeStartTime onlyOwner{
        tokenStorage.vestingPeriod = period ;
    }

    function setVestingPercent(uint256 percent) public beforeStartTime onlyOwner{
        tokenStorage.vestingPercent = percent ;
    }

    function setSoftCap(uint256 value) public beforeStartTime onlyOwner{
        tokenStorage.softCap = value ;
    }

    function setHardCap(uint256 value) public beforeStartTime onlyOwner{
        tokenStorage.hardCap = value ;
    }

    function setMinBuy(uint256 value) public beforeStartTime onlyOwner{
        tokenStorage.minBuy = value ;
    }

    function setMaxBuy(uint256 value) public beforeStartTime onlyOwner{
        tokenStorage.maxBuy = value ;
    }

    function setRefundType(bool state) public onlyOwner{
        tokenStorage.refundType = state ;
    }

    function setLiquidityPercent(uint256 percent) public beforeStartTime onlyOwner{
        tokenStorage.liquidityPercent = percent ;
    }

    function setListingPrice(uint256 value) public beforeStartTime onlyOwner{
        tokenStorage.listingPrice = value ;
    }

    function setStatTime(uint256 value) public beforeStartTime onlyOwner{
        require(value < tokenStorage.startTime, "Can not be reset after start time") ;
        tokenStorage.startTime = value ;
    }

    function setEndTime(uint256 value) public beforeStartTime onlyOwner{
        require(value > tokenStorage.startTime, "Can not be smaller than start time") ;
        tokenStorage.endTime = value ;
    }

    function setLockupTime(uint256 value) public beforeStartTime onlyOwner{
        tokenStorage.lockupTime = value ;
    }

    /// Returns the token information in tokenStorage
    
    function getSaleOption() public view returns(SaleOption){
    
        return tokenStorage.saleOption ;
    
    }


    function getPreSalePrice() public view returns(uint256){
        
        return tokenStorage.preSalePrice ;

    }

    function getPreSalePercent() public view returns(uint256){
        
        return tokenStorage.preSalePercent ;

    }

    function getWhiteListState() public view returns(bool){
        
        return tokenStorage.whiteListState ;

    }

     function getVestingPeriod() public view returns(uint256){
        return tokenStorage.vestingPeriod ;
    }

    function getVestingPercent() public view returns(uint256){
        return tokenStorage.vestingPercent ;
    }

    function getSoftCap() public view returns(uint256){
        
        return tokenStorage.softCap ;

    }

    function getHardCap() public view returns(uint256){
        
        return tokenStorage.hardCap ;

    }

    function getMinBuy() public view returns(uint256){
        
        return tokenStorage.minBuy ;

    }

    function getMaxBuy() public view returns(uint256){
        
        return tokenStorage.maxBuy ;

    }

    function getRefundType() public view returns(bool){
        
        return tokenStorage.refundType ;

    }

    function getLiquidityPercent() public view returns(uint256){
        
        return tokenStorage.liquidityPercent ;

    }

    function getListingPrice() public view returns(uint256){
        
        return tokenStorage.listingPrice ;

    }

    function getStartTime() public view returns(uint256){
        
        return tokenStorage.startTime ;

    }

    function getEndTime() public view returns(uint256){
        
        return tokenStorage.endTime ;

    }

    function getLockupTime() public view returns(uint256){
        
        return tokenStorage.lockupTime ;

    }

    function getAmountSold() public view returns(uint256){
        
        return tokenStorage.amountSold ;

    }

    function getEarnings() public view returns(uint256){
        
        return tokenStorage.earnings ;

    }

    // the owner withdraw token left after Pre Sale
    function withdrawToken(uint amount) public onlyOwner afterEndTime{
        require(tokenStorage.refundType == true, "refund type should be true to withdraw tokens") ;
        require(amount <= tokenStorage.leftAmount, "amount can not exceed left amount") ;
        tokenStorage.leftAmount = amount ;
        _transfer(address(this), msg.sender, amount * _unit()) ;
    }
    
    // Allows operator to deal with msg.sender's NFTs
    function setApprovalForAll(address operator, bool approved) public {
        _setApprovalForAll(operator, approved, msg.sender);
    }  

    // Transfer NFT(id) from -> to
    function transferFromNFT(address from, address to, uint256 Id) public {
        _transferFromNFT(from, to, Id, msg.sender) ;
    }

    receive() external override payable{}
    fallback() external override payable{}
}
