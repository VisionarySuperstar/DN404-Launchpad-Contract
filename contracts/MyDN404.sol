/**

www.WrappedPlatform.com

⠀⠀⠀⣠⠖⠚⠉⠙⠲⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠾⠋⠉⠑⠢⣄⠀⠀⠀⠀⠀
⠀⢀⡞⠁⠀⠀⠀⠀⠀⠈⠓⠦⠤⠤⠴⠖⠒⠉⠉⠉⠉⠉⠉⠉⠒⠲⠦⠤⠤⠴⠟⠁⠀⠀⠀⠀⠀⠈⢷⡀⠀⠀⠀
⠀⣾⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣧⠀⠀⠀
⢸⡇⢀⡴⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢦⠀⢹⣆⠀⠀
⠈⢧⡞⣴⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣶⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠠⣤⢧⡾⠙⠀⠀
⠀⠈⢿⡇⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⣾⣣⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⠀⠀⠀⠀⢹⡾⠀⠀⠀⠀
⠀⠀⠘⣇⠀⠀⢀⡾⠀⠀⠀⠀⣾⣿⠀⠀⢸⣯⣿⣿⣿⣿⡇⠀⠀⣿⣷⠄⠀⠀⠀⠀⠈⣷⠀⠀⠀⣼⠁⠀⠀⠀⠀
⠀⠀⠀⠈⠳⠤⣼⠁⠀⠀⠀⠀⠈⠁⠀⠀⠸⣿⣿⣿⣿⣿⡇⠀⠀⠈⠉⠀⠀⠀⠀⠀⠀⠘⣧⠤⠞⠁⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠻⠿⠿⠿⠟⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣹⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠘⠲⠴⠟⠦⠴⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡟⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠹⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⢦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣶⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⠋⠁⠀⠀⠀⠀⠀⢀⡖⠚⣻⠀⠀⠀⠀⠀⠀⠀⠈⢻⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡏⠀⠀⠀⣾⠉⠙⢲⣼⡤⠞⠉⠀⠀⠀⢐⡆⠀⠀⠀⠈⣯⢧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠇⠀⠀⠀⠈⣩⠉⠉⠙⣆⠀⠀⠀⠀⠀⣸⠇⠀⠀⠀⠀⢹⡈⢷⡄⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⠀⠀⠀⠀⢰⡏⠀⠀⠀⠸⡆⠀⠀⣠⡶⠋⠀⠀⠀⠀⠀⢸⡇⠀⢿⡀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⡏⠀⠀⠀⠀⢸⡇⠀⠀⠀⢀⡿⠶⠋⠉⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⠘⣗⠲⣆⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢠⡖⠋⠙⠲⡇⠀⠀⠀⠀⢸⠀⣰⠤⢥⣿⠤⠤⠄⠀⠀⠀⠀⠀⣀⣤⠞⠁⠀⠀⠀⢹⡆⠛⢶⡄⠀⠀⠀
⠀⠀⠀⠀⡟⠀⠀⠀⠀⡇⠀⠀⠀⠀⢸⣸⠃⠀⠀⠙⢷⣖⣃⣠⡤⠴⠖⠋⠉⠀⠀⠀⠀⠀⠀⠈⣷⠀⡼⠃⠀⠀⠀
⠀⠀⠀⢸⡇⠀⠀⠀⠀⡇⠀⠀⠀⠀⢸⡟⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣠⠏⠀⠀⠀⠀
⠀⠀⠀⠈⣧⠀⠀⠀⠀⣷⠀⠀⠀⠀⣼⣇⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡿⠋⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠘⣧⠀⠀⠀⢿⣀⡀⠀⠀⡿⢻⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡴⠟⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠈⠳⠤⠤⠼⢷⣇⣸⡾⠓⠚⠳⣄⣀⠀⠀⠀⠀⣀⣀⣀⣠⡤⠤⠴⠖⠛⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 _  _  _                                 _    ______  _             ___                  
| || || |                               | |  (_____ \| |      _    / __)                 
| || || | ____ ____ ____  ____   ____ _ | |   _____) ) | ____| |_ | |__ ___   ____ ____  
| ||_|| |/ ___) _  |  _ \|  _ \ / _  ) || |  |  ____/| |/ _  |  _)|  __) _ \ / ___)    \ 
| |___| | |  ( ( | | | | | | | ( (/ ( (_| |  | |     | ( ( | | |__| | | |_| | |   | | | |
 \______|_|   \_||_| ||_/| ||_/ \____)____|  |_|     |_|\_||_|\___)_|  \___/|_|   |_|_|_|
                   |_|   |_|                                                             ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 */
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./DN404.sol";
import "./DN404Mirror.sol";
import "hardhat/console.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

/**
 * @title MyDN404
 * @notice Sample DN404 contract that demonstrates the owner selling NFTs rather than the fungible token.
 * The underlying call still mints ERC20 tokens, but to the end user it'll appear as a standard NFT mint.
 * Each address is limited to MAX_PER_WALLET total mints.
 */
contract MyDN404 is DN404 {
    using Strings for uint256;

    string public _name;
    string public _symbol;
    string public _baseURI;

    address public ownerAddress;

    // proxy contract address
    address private proxy;

    // tax for users during buy and sell
    uint256 public taxForBuy;
    uint256 public taxForSell;

    mapping(address => uint256) public buyAmountUser;
    mapping(address => uint256) public soldAmountUser;
    mapping(address => uint256) public buyTimeUser;

    // enum SaleOption {PRESALE, STEALTH, FAIR_LAUNCH}
    struct Customer404Storage {
        SaleOption saleOption;
        uint256 preSalePrice;
        uint256 preSalePercent;
        bool whiteListState;
        uint256 vestingPeriod;
        uint256 vestingPercent;
        uint256 softCap;
        uint256 hardCap;
        uint256 minBuy;
        uint256 maxBuy;
        bool refundType;
        uint256 liquidityPercent;
        uint256 listingPrice;
        uint256 startTime;
        uint256 endTime;
        uint256 lockupTime;
        uint256 amountSold;
        uint256 earnings;
        uint256 leftAmount;
        bool isEnded;
    }

    Customer404Storage public tokenStorage;


    // Modifiers

    modifier onlyOwner() {
        require(msg.sender == ownerAddress, "Owner address is only allowed");
        _;
    }
    modifier beforeStartTime() {
        require(
            block.timestamp <= tokenStorage.startTime,
            "Should be less than start time"
        );
        _;
    }

    modifier afterEndTime() {
        require(
            block.timestamp >= tokenStorage.endTime,
            "Should be after the end time"
        );
        _;
    }

    event Buy(address from, uint256 amount);
    event PresaleFinish(uint256 amount);

    // This function is called when token created
    function initialize(
        string memory name_,
        string memory symbol_,
        uint256 initialTokenSupply,
        bytes memory _ownerData
    ) external initializer {
        address _owner = abi.decode(_ownerData, (address));
        ownerAddress = _owner;
        _name = name_;
        _symbol = symbol_;
        initialTokenSupply *= _unit();
        address mirror = address(new DN404Mirror(msg.sender));
        _initializeDN404(initialTokenSupply, _owner, mirror);
        proxy = msg.sender;
    }

    // get buyFee and sellFee from proxy contract
    function setBuyAndSellFee(uint256 _taxForBuy, uint256 _taxForSell) public {
        require(msg.sender == proxy, "Only proxy can set fees");
        taxForBuy = _taxForBuy;
        taxForSell = _taxForSell;
    }
    // set all of token informations from owner
    function setAllOfSettings(
        SaleOption _saleOption,
        uint256 _preSalePrice,
        uint256 _preSalePercent,
        bool _whiteListState,
        uint256 _vestingPeriod,
        uint256 _vestingPercent,
        uint256 _softCap,
        uint256 _hardCap,
        uint256 _minBuy,
        uint256 _maxBuy,
        bool _refundType,
        uint256 _startTime,
        uint256 _endTime,
        string memory baseURI,
        uint256 _taxForSell
    ) public onlyOwner {
        // Setting the initialization parameters
        tokenStorage.saleOption = _saleOption;
        tokenStorage.preSalePrice = _preSalePrice;
        tokenStorage.preSalePercent = _preSalePercent;
        tokenStorage.whiteListState = _whiteListState;
        tokenStorage.vestingPeriod = _vestingPeriod;
        tokenStorage.vestingPercent = _vestingPercent;
        tokenStorage.softCap = _softCap;
        tokenStorage.hardCap = _hardCap;
        tokenStorage.minBuy = _minBuy;
        tokenStorage.maxBuy = _maxBuy;
        tokenStorage.refundType = _refundType;
        tokenStorage.startTime = _startTime;
        tokenStorage.endTime = _endTime;
        tokenStorage.amountSold = 0;
        tokenStorage.leftAmount = totalSupply() * _preSalePercent;
        taxForSell = _taxForSell ;
        _baseURI = baseURI;

        // put this contract as whitelisted so that NFT mint does not happen
        _setSkipNFT(address(this), true);
    }

    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        if (
            tokenStorage.saleOption == SaleOption.PRESALE &&
            buyAmountUser[from] > 0
        ) {
            uint256 _amount = buyAmountUser[from];
            uint256 currentTime = block.timestamp;
            uint256 amountAvailableForSell = ((((currentTime -
                buyTimeUser[from]) / (tokenStorage.vestingPeriod * 3600 * 24)) *
                tokenStorage.vestingPercent) * _amount) / 100;
            require(
                amountAvailableForSell <= soldAmountUser[from] + amount,
                "You could sell this amount."
            );
            soldAmountUser[from] += amount;
        }
        super._transfer(from, to, amount);
    }

    // Main process for buying tokens during PreSell
    function buyTokenDuringPreSell(uint256 amount) external payable {
        if (tokenStorage.saleOption == SaleOption.STEALTH) {
            return;
        }
        if (tokenStorage.whiteListState) {
            // Check if msg.sender is valid for buying because owner selected as whitelist members can buy tokens during PreSell
            bool isWhiteListedAddress = _getSkipNFT(msg.sender);
            require(isWhiteListedAddress, "Address not in whitelist");
        } else {
            // Set msg.sender as a whitelist member to prevent NFT mint during PreSell
            _setSkipNFT(msg.sender, true);
        }
        // Check if PreSell is active
        require(
            block.timestamp >= tokenStorage.startTime &&
                block.timestamp <= tokenStorage.endTime,
            "Sale is not active"
        );
        require(tokenStorage.isEnded == false, "Already finished!");

        // Check minimum and maximum amount
        require(
            amount >= tokenStorage.minBuy &&
                amount + buyAmountUser[msg.sender] <= tokenStorage.maxBuy,
            "Amount is not within limits"
        );

        // Check if all amounts exceeds the presale amount
        uint256 currentvalue = (totalSupply() * tokenStorage.preSalePercent) /
            100;
        require(
            amount + tokenStorage.amountSold <= currentvalue,
            "Presale limit exceeded"
        );

        uint256 payAmount = amount  / tokenStorage.preSalePrice;
        require(msg.value >= payAmount, "Not enough ETH sent");

        // Refund extra amount if any
        uint256 amountToRefund = msg.value - payAmount;
        if (amountToRefund > 0) {
            payable(msg.sender).transfer(amountToRefund);
        }

        // Transfer tokens
        _transfer(address(this), msg.sender, amount);

        buyAmountUser[msg.sender] += amount;
        buyTimeUser[msg.sender] = block.timestamp;

        // token left amount
        tokenStorage.leftAmount -= amount;

        // add sold amount
        unchecked {
            tokenStorage.amountSold += amount;
        }

        if (tokenStorage.amountSold >= tokenStorage.hardCap) { 
            
            tokenStorage.endTime = block.timestamp - 1;
            finish();
        }

        emit Buy(msg.sender, amount);
    }

    function finish() public{
        console.log("finish111") ;
        require(block.timestamp >= tokenStorage.endTime, "Already not finished.") ;
        require(tokenStorage.amountSold >= tokenStorage.softCap, "Softcap arrived!") ;
        uint256 fee = tokenStorage.amountSold * taxForSell / 100 ;
        uint256 amountForOwner = tokenStorage.amountSold - fee ;
        payable(proxy).transfer(fee / tokenStorage.preSalePrice) ;
        payable(ownerAddress).transfer(amountForOwner / tokenStorage.preSalePrice) ;
        tokenStorage.isEnded = true ;
        console.log("1") ;
        if(tokenStorage.refundType == false){
            // burn tokens
            _burn(address(this), balanceOf(address(this)));
        }
        console.log("here") ;
        emit PresaleFinish(tokenStorage.amountSold) ;
    }

    // Function to set the data URI, which can be used for additional metadata (change as needed)
    function setBaseURI(string calldata baseURI) public onlyOwner {
        _baseURI = baseURI;
    }

    // tokenURI function to return the base URI for token metadata; users can implement logic to return unique URIs per token ID
    function tokenURI(uint256 tokenId) external view returns (string memory) {
        return _tokenURI(tokenId);
    }

    function _tokenURI(
        uint256 tokenId
    ) internal view virtual override returns (string memory) {
        require(!_exists(tokenId), "Invalid token");

        string memory baseURI = baseURI_();
        return
            bytes(baseURI).length != 0
                ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json"))
                : "";
    }
    function baseURI_() internal view returns (string memory) {
        return _baseURI;
    }

    // Returns token name
    function name() public view override returns (string memory) {
        return _name;
    }

    // Returns token symbol
    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    // Allows the owner to update the token's name and symbol post-deployment (optional flexibility)
    function setNameSymbol(
        string calldata name__,
        string memory symbol__
    ) public onlyOwner {
        _name = name__;
        _symbol = symbol__;
    }

    // Allows owner to upload address to whitelist
    function setWhitelist(address to, bool state) public onlyOwner {
        _setSkipNFT(to, state);
    }

    // Allows owner to upload addresses to white list
    function setWhitelistBatch(
        address[] calldata targets,
        bool[] calldata state
    ) public onlyOwner {
        for (uint256 i = 0; i < targets.length; i++) {
            _setSkipNFT(targets[i], state[i]);
        }
    }

    /// Reset the token information in tokenStorage

    function setSaleOption(SaleOption option) public beforeStartTime onlyOwner {
        tokenStorage.saleOption = option;
    }

    function setPreSalePrice(uint256 price) public beforeStartTime onlyOwner {
        tokenStorage.preSalePrice = price;
    }

    function setPreSalePercent(
        uint256 percent
    ) public beforeStartTime onlyOwner {
        tokenStorage.preSalePercent = percent;
    }

    function setWhitelistState(bool state) public onlyOwner {
        tokenStorage.whiteListState = state;
    }

    function setVestingPeriod(uint256 period) public beforeStartTime onlyOwner {
        tokenStorage.vestingPeriod = period;
    }

    function setVestingPercent(
        uint256 percent
    ) public beforeStartTime onlyOwner {
        tokenStorage.vestingPercent = percent;
    }

    function setSoftCap(uint256 value) public beforeStartTime onlyOwner {
        tokenStorage.softCap = value;
    }

    function setHardCap(uint256 value) public beforeStartTime onlyOwner {
        tokenStorage.hardCap = value;
    }

    function setMinBuy(uint256 value) public beforeStartTime onlyOwner {
        tokenStorage.minBuy = value;
    }

    function setMaxBuy(uint256 value) public beforeStartTime onlyOwner {
        tokenStorage.maxBuy = value;
    }

    function setRefundType(bool state) public onlyOwner {
        tokenStorage.refundType = state;
    }

    function setLiquidityPercent(
        uint256 percent
    ) public beforeStartTime onlyOwner {
        tokenStorage.liquidityPercent = percent;
    }

    function setListingPrice(uint256 value) public beforeStartTime onlyOwner {
        tokenStorage.listingPrice = value;
    }

    function setStatTime(uint256 value) public beforeStartTime onlyOwner {
        require(
            value < tokenStorage.startTime,
            "Can not be reset after start time"
        );
        tokenStorage.startTime = value;
    }

    function setEndTime(uint256 value) public beforeStartTime onlyOwner {
        require(
            value > tokenStorage.startTime,
            "Can not be smaller than start time"
        );
        tokenStorage.endTime = value;
    }

    function setLockupTime(uint256 value) public beforeStartTime onlyOwner {
        tokenStorage.lockupTime = value;
    }

    /// Returns the token information in tokenStorage

    function getSaleOption() public view returns (SaleOption) {
        return tokenStorage.saleOption;
    }

    function getPreSalePrice() public view returns (uint256) {
        return tokenStorage.preSalePrice;
    }

    function getPreSalePercent() public view returns (uint256) {
        return tokenStorage.preSalePercent;
    }

    function getWhiteListState() public view returns (bool) {
        return tokenStorage.whiteListState;
    }

    function getVestingPeriod() public view returns (uint256) {
        return tokenStorage.vestingPeriod;
    }

    function getVestingPercent() public view returns (uint256) {
        return tokenStorage.vestingPercent;
    }

    function getSoftCap() public view returns (uint256) {
        return tokenStorage.softCap;
    }

    function getHardCap() public view returns (uint256) {
        return tokenStorage.hardCap;
    }

    function getMinBuy() public view returns (uint256) {
        return tokenStorage.minBuy;
    }

    function getMaxBuy() public view returns (uint256) {
        return tokenStorage.maxBuy;
    }

    function getRefundType() public view returns (bool) {
        return tokenStorage.refundType;
    }

    function getLiquidityPercent() public view returns (uint256) {
        return tokenStorage.liquidityPercent;
    }

    function getListingPrice() public view returns (uint256) {
        return tokenStorage.listingPrice;
    }

    function getStartTime() public view returns (uint256) {
        return tokenStorage.startTime;
    }

    function getEndTime() public view returns (uint256) {
        return tokenStorage.endTime;
    }

    function getLockupTime() public view returns (uint256) {
        return tokenStorage.lockupTime;
    }

    function getAmountSold() public view returns (uint256) {
        return tokenStorage.amountSold;
    }

    function getEarnings() public view returns (uint256) {
        return tokenStorage.earnings;
    }

    // the owner withdraw token left after Pre Sale
    function withdrawToken() public onlyOwner afterEndTime {
        require(
            tokenStorage.refundType == true,
            "refund type should be true to withdraw tokens"
        );
        uint256 amount = balanceOf(address(this));
        _transfer(address(this), msg.sender, amount);
    }

    function withdrawFromBuyers() public afterEndTime {
        require(tokenStorage.isEnded == false, "Already successed project!");
        uint256 amount = buyAmountUser[msg.sender];
        buyAmountUser[msg.sender] = 0;
        _transfer(msg.sender, ownerAddress, amount);
        uint256 refundAmount = amount / tokenStorage.preSalePrice;
        payable(msg.sender).transfer(refundAmount);
    }

    // Allows operator to deal with msg.sender's NFTs
    function setApprovalForAll(address operator, bool approved) public {
        _setApprovalForAll(operator, approved, msg.sender);
    }

    // Transfer NFT(id) from -> to
    function transferFromNFT(address from, address to, uint256 Id) public {
        _transferFromNFT(from, to, Id, msg.sender);
    }

    receive() external payable override {}
    fallback() external payable override {}
}
